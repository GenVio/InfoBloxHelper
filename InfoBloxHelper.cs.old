using System;
using System.Text;
using System.Globalization;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Net;
using System.Net.Security;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Security.Cryptography.X509Certificates;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using KPMG.KTech.Automation.InfoBlox.Model;

namespace KPMG.KTech.Automation.InfoBlox
{
    public class Helper
    {
        private static HttpClient httpClient;
        private static HttpClientHandler handler = new HttpClientHandler();
        private static bool isClientInitialized = false;
        private static UriBuilder uriBuilder = new UriBuilder();
        public Helper()
        {

        }

        public async Task<List<InfobloxNetwork>> RetrieveNetworkLists()
        {

            string _username = "admin";
            string _password = "Zuerich#14";
            Uri _infoBloxURI = new Uri("https://104.210.216.95/wapi/v2.9/network");
            string _credentials = Convert.ToBase64String(Encoding.ASCII.GetBytes($"{_username}:{_password}"));
            bool _acceptInvalidSSL = true;

            //Configuration(out _infoBloxURI, out _credentials, out _acceptInvalidSSL);

            //The request will not validate the certificate from the server (testing/poc) -- DO NOT DEPLOY in production with the flag equals to true
            if (_acceptInvalidSSL)
            {
                //Accept all server certificate (Y/n)
                handler.ClientCertificateOptions = ClientCertificateOption.Manual;
                handler.ServerCertificateCustomValidationCallback = (httpRequestMessage, cert, cetChain, policyErrors) => { return _acceptInvalidSSL; };

                //The HttpClient is pooled to increase performance and scalability of connections.
                if (!isClientInitialized)
                {
                    httpClient = new HttpClient(handler, false);
                    isClientInitialized = true;
                }
            }
            else
            // This path is taken if the application is in Production vs. Test/Dev
            {

                //The HttpClient is pooled to increase performance and scalability of connections.
                if (!isClientInitialized)
                {
                    httpClient = new HttpClient();
                    isClientInitialized = true;
                }
            }


            HttpRequestMessage _reqMessage = new HttpRequestMessage();

            _reqMessage.Headers.Authorization = new AuthenticationHeaderValue("Basic", _credentials);

            _reqMessage.RequestUri = _infoBloxURI;
            _reqMessage.Method = HttpMethod.Get;
            //_reqMessage.Content = new StringContent(iprequested, Encoding.UTF8, "application/json");


            HttpResponseMessage _httpResponse = await httpClient.SendAsync(_reqMessage);

            //Get the response back
            string content = await _httpResponse.Content.ReadAsStringAsync();
            _httpResponse.EnsureSuccessStatusCode();
            return InfobloxNetwork.FromJson(content);

        }
        public async Task<IpResult> RetrieveIP(int totalIPRequested = 1)
        {
            Uri _infoBloxURI;
            string _credentials;
            bool _acceptInvalidSSL;

            if (totalIPRequested <= 0)
            {
                return null;
            }

            string iprequested = new IpRequest(totalIPRequested).ToJson();

            Configuration(out _infoBloxURI, out _credentials, out _acceptInvalidSSL);

            //The request will not validate the certificate from the server (testing/poc) -- DO NOT DEPLOY in production with the flag equals to true
            if (_acceptInvalidSSL)
            {
                //Accept all server certificate (Y/n)
                handler.ClientCertificateOptions = ClientCertificateOption.Manual;
                handler.ServerCertificateCustomValidationCallback = (httpRequestMessage, cert, cetChain, policyErrors) => { return _acceptInvalidSSL; };

                //The HttpClient is pooled to increase performance and scalability of connections.
                if (!isClientInitialized)
                {
                    httpClient = new HttpClient(handler, false);
                    isClientInitialized = true;
                }
            }
            else
            // This path is taken if the application is in Production vs. Test/Dev
            {

                //The HttpClient is pooled to increase performance and scalability of connections.
                if (!isClientInitialized)
                {
                    httpClient = new HttpClient();
                    isClientInitialized = true;
                }
            }


            HttpRequestMessage _reqMessage = new HttpRequestMessage();

            _reqMessage.Headers.Authorization = new AuthenticationHeaderValue("Basic", _credentials);

            _reqMessage.RequestUri = _infoBloxURI;
            _reqMessage.Method = HttpMethod.Post;
            _reqMessage.Content = new StringContent(iprequested, Encoding.UTF8, "application/json");


            HttpResponseMessage _httpResponse = await httpClient.SendAsync(_reqMessage);

            //Get the response back
            string content = await _httpResponse.Content.ReadAsStringAsync();
            _httpResponse.EnsureSuccessStatusCode();

            return IpResult.FromJson(content);
        }
        public async Task<string> CreateHostRecord(string HostName)
        {

            Uri _infoBloxURI;
            string _credentials;
            bool _acceptInvalidSSL;

            // if (IsNullOrEmpty(HostName))
            // {
            //     return null;
            // }

            //string iprequested = new IpRequest(totalIPRequested).RequestToJson();

            Configuration(out _infoBloxURI, out _credentials, out _acceptInvalidSSL);

            //The request will not validate the certificate from the server (testing/poc) -- DO NOT DEPLOY in production with the flag equals to true
            if (_acceptInvalidSSL)
            {
                //Accept all server certificate (Y/n)
                handler.ClientCertificateOptions = ClientCertificateOption.Manual;
                handler.ServerCertificateCustomValidationCallback = (httpRequestMessage, cert, cetChain, policyErrors) => { return _acceptInvalidSSL; };

                //The HttpClient is pooled to increase performance and scalability of connections.
                if (!isClientInitialized)
                {
                    httpClient = new HttpClient(handler, false);
                    isClientInitialized = true;
                }
            }
            else
            // This path is taken if the application is in Production vs. Test/Dev
            {

                //The HttpClient is pooled to increase performance and scalability of connections.
                if (!isClientInitialized)
                {
                    httpClient = new HttpClient();
                    isClientInitialized = true;
                }
            }


            HttpRequestMessage _reqMessage = new HttpRequestMessage();

            _reqMessage.Headers.Authorization = new AuthenticationHeaderValue("Basic", _credentials);

            _reqMessage.RequestUri = _infoBloxURI;
            _reqMessage.Method = HttpMethod.Post;
            //   _reqMessage.Content = new StringContent(iprequested, Encoding.UTF8, "application/json");


            HttpResponseMessage _httpResponse = await httpClient.SendAsync(_reqMessage);

            //Get the response back
            string content = _httpResponse.Content.ReadAsStringAsync().Result;


            _httpResponse.EnsureSuccessStatusCode();


            // return IpResult.FromJson(content);
            return (null);
        }
        public async Task UpdateHostRecord()
        { }
        public async Task DeleteHostRecord()
        { }

        private void Configuration(out Uri infoBloxURI, out string credentials, out bool acceptInvalidSSL)
        {
            string _username = "admin";
            string _password = "Zuerich#14";
            infoBloxURI = new Uri("https://104.210.216.95/wapi/v2.9/network/ZG5zLm5ldHdvcmskMTAuMTI4LjAuMC8yNC8w?_function=next_available_ip");
            credentials = Convert.ToBase64String(Encoding.ASCII.GetBytes($"{_username}:{_password}"));
            acceptInvalidSSL = true;
        }
    }
    public class InfoBloxConfiguration
    {
        public string Username { get; set; }
        public string Password { get; set; }
        public Uri InfoBloxServer { get; set; }
        public bool AcceptInvalidSSL { get; set; }
    }

}

